# 实验原理

## 1. 整数原码除法

&emsp;&emsp;原码除法，顾名思义是被除数、除数、商和余数均采用原码表示的除法。

&emsp;&emsp;与小数的原码除法相同，整数的原码除法同样是将符号和数值分开运算的。

&emsp;&emsp;令 $[x]_原 = x_0x_1x_2 \cdots x_n$，$[y]_原 = y_0y_1y_2 \cdots y_n$，则有：

$$
[\frac{x}{y}]_原 = (x_0 \oplus y_0) \cdot \frac{x_1x_2 \cdots x_n}{y_1y_2 \cdots y_n}
$$

&emsp;&emsp;其中，$x_0$、$y_0$ 分别为 $x$、$y$ 的符号；  
&emsp;&emsp;&emsp;&emsp;&emsp;$x_1x_2 \cdots x_n$ 为 $x$ 的绝对值，记作 $x^*$；  
&emsp;&emsp;&emsp;&emsp;&emsp;$y_1y_2 \cdots y_n$ 为 $y$ 的绝对值，记作 $y^*$。

&emsp;&emsp;由上式可知，在原码除法运算中，商的值由被除数和除数的绝对值相除求得，即 $\frac{x^*}{y^*}$；商的符号由被除数、除数的符号位经过异或运算求得，即 $x_0 \oplus y_0$。余数的符号与被除数相同。

### 1.1 恢复余数法

&emsp;&emsp;假设被除数、除数的 <u>**数据位宽**</u> 均为 $n$，则基于恢复余数法的原码除法步骤如下：

&emsp;&emsp;***Step1***：令被除数（余数）减去 $y^*$，即加上 $[-y^*]_补$；

&emsp;&emsp;***Step2***：若得到的余数为负数，表明不够减，故商上 $0$，并加上 $y^*$ 以恢复余数；  
&emsp;&emsp;&emsp;&emsp;&emsp;&ensp;若得到的余数为正数，表明够减，故商上 $1$；

&emsp;&emsp;***Step3***：若左移次数小于 $n$，令被除数（余数）左移 $1$ 位，回到 ***Step1***；  
&emsp;&emsp;&emsp;&emsp;&emsp;&ensp;否则结束算法，此时的被除数即为余数。

!!! example "举个栗子 :chestnut:"
    &emsp;&emsp;设被除数 $x$ = +`1101B`，除数 $y$ = -`0110B`；$x$ 的绝对值 $x^*$ = `01101B`，$y$ 的绝对值 $y^*$ = `00110B`，$y^*$ 的补码 $[-y^*]_补$ = `11010B`，则有：

    === "原始的恢复余数法"
        <center><img src="../assets/2-1a.png" width = 440></center>
        <center>图2-1 恢复余数法示例</center>

    === "简化的恢复余数法"
        <center><img src="../assets/2-1b.png" width = 442></center>
        <center>图2-1 恢复余数法示例</center>

    &emsp;&emsp;注意，在本例子中，$x$ 和 $y$ 的数据位宽均为4位（最高位的符号位不算入内），故左移次数应是4。  
    &emsp;&emsp;通过观察容易发现，由于被除数的绝对值最多只有4位，故被除数（余数）首次加上 $[-y^*]_补$ 后，所得结果必定为负，必定需要恢复余数，即第一轮循环的有效操作仅仅是将被除数（余数）左移了一次。由此，可将恢复余数法进行简化，省去第一轮循环。

### 1.2 加减交替法

&emsp;&emsp;假设被除数、除数的 <u>**数据位宽**</u> 均为 $n$，则基于加减交替法的原码除法步骤如下：

&emsp;&emsp;***Step1***：令被除数减去 $y^*$，即加上 $[-y^*]_补$；

&emsp;&emsp;***Step2***：若得到的余数为负数，表明不够减，故商上 $0$，令被除数左移 $1$ 位，再加上 $[y^*]_补$；  
&emsp;&emsp;&emsp;&emsp;&emsp;&ensp;若得到的余数为正数，表明够减，故商上 $1$， 令被除数左移 $1$ 位，再加上 $[-y^*]_补$；

&emsp;&emsp;***Step3***：若左移次数已达 $n$ 次，结束，此时的被除数即为余数；否则回到 ***Step2***。

!!! example "再举一个 :chestnut:"
    &emsp;&emsp;设被除数 $x$ = +`1101B`，除数 $y$ = -`0110B`；$x$ 的绝对值 $x^*$ = `01101B`，$y$ 的绝对值 $y^*$ = `00110B`，$y^*$ 的补码 $[-y^*]_补$ = `11010B`，则有：

    === "原始的加减交替法"
        <center><img src="../assets/2-2a.png" width = 440></center>
        <center>图2-2 加减交替法示例</center>

    === "简化的加减交替法"
        <center><img src="../assets/2-2b.png" width = 442></center>
        <center>图2-2 加减交替法示例</center>

    &emsp;&emsp;同样地，$x$ 和 $y$ 的数据位宽均为4位，故原本需左移4次。  
    &emsp;&emsp;通过观察容易发现，由于被除数的绝对值最多只有4位，故首次循环时，$[-y^*]_补$ 总是与被除数（余数）高位的 $4'b0000$ 相加，然后随着被除数（余数）左移1位，接着再加上 $[y^*]_补$ 。这一系列操作可以简化为将 $[-y^*]_补$ 直接与左移1位的被除数相加，原理如下：
    
    $$
    \begin{aligned}
    \hspace{0pt}
        \{[-y^*]_补, x^*\} << 1 + \{[y^*]_补, 4'b0000\} \quad &= \quad 2^{4+1} \cdot [-y^*]_补 + 2^1 \cdot x^* + 2^4 \cdot [y^*]_补 \\
        &= \quad 2^4 \cdot (2 \cdot [-y^*]_补 + [y^*]_补) + 2^1 \cdot x^* \\
        &= \quad 2^4 \cdot [-y^*]_补 + 2^1 \cdot x^* \\
        &= \quad \{[-y^*]_补, 4'b0000\} + (x^* << 1)
    \end{aligned}
    $$



## 2. 除法器设计原理

### 2.1 除法器参考架构

&emsp;&emsp;分析原理可知，原码除法包含求补、加法、左移、异或操作，在运算过程中还需判断被除数（余数）的符号从而选择不同的操作，并在循环一定次数后结束运算。

&emsp;&emsp;求补、加法、左移、异或操作很容易通过组合逻辑实现；符号判断可通过特定的控制逻辑实现；而循环次数的控制则可通过计数器实现。

&emsp;&emsp;此处给出源码除法器的参考实现架构，如图2-3所示。

<center><img src="../assets/2-3.png" width = 300></center>
<center>图2-3 原码除法器参考架构</center>

&emsp;&emsp;在图2-3中，深蓝色箭头表示数据，深橙色箭头则表示控制信号。

&emsp;&emsp;控制逻辑接受2个输入：一个是被除数（余数）的符号位，另一个则是计数器的计时结束信号。控制逻辑产生3个控制信号：一个控制被除数（余数）需要与 $[y^*]_补$ 还是与 $[-y^*]_补$ 相加，即控制图2-3中的多路选择器；另外一个控制被除数（余数）的左移；还有一个控制上商。

&emsp;&emsp;复位时，各寄存器均被清零，计数器被复位。运算时，控制逻辑通过判断被除数（余数）最高位的符号位，控制上商以及加法器的数据源选择；加法器将被除数（余数）的高8位与 $[y^*]_补$ 或 $[-y^*]_补$ 相加，结果更新到被除数（余数）；此外，控制逻辑接收计数器的计时信号，控制被除数（余数）的移位操作，并在移位6次后结束除法运算。

### 2.2 除法器接口信号

&emsp;&emsp;原码除法器模块的接口信号如表2-1所示。

<center>表2-1 原码除法器接口信号</center>
<center>

| 序号 | 名称 | 位宽 | 属性 | 功能描述 |
| :-: | :-: | :-: | :-: | :-: |
| 1 | clk | 1 | 输入 | 时钟信号 |
| 2 | rst | 1 | 输入 | 复位信号（**高电平有效**） |
| 3 | x | 8 | 输入 | 被除数（原码） |
| 4 | y | 8 | 输入 | 除数（原码） |
| 5 | start | 1 | 输入 | 启动信号 |
| 6 | z | 8 | 输出 | 商（原码） |
| 7 | r | 8 | 输出 | 余数（原码） |
| 8 | busy | 1 | 输出 | 忙标志信号 |

</center>

&emsp;&emsp;表2-1所示的原码除法器接口信号应当满足如图2-4所示的时序。

<center><img src="../assets/2-4.png" width = 430></center>
<center>图2-4 原码除法器接口信号时序</center>

&emsp;&emsp;由图2-4可知，当`start`信号有效时，被除数`x`和除数`y`将有效。注意，**`start`、`x`和`y`信号仅有效一个时钟**，因此除法器必须将先被除数`x`和除数`y`缓存下来，并在下一个时钟拉高`busy`信号，表示正在进行除法运算。在除法运算结束后，除法器需将`busy`信号拉低，同时将商和余数分别输出到`z`和`r`。

&emsp;&emsp;TestBench在检测到`busy`信号有效时，将进入等待状态；当`busy`信号被拉低后，TestBench将读取商`z`和余数`r`，并对除法运算的结果进行正确性检查。若检查通过，则TestBench将继续发送下一组测试数据，否则将报错并结束测试。

## 3. SoC基本架构

&emsp;&emsp;CPU由数据通路和控制器组成，其主要功能是控制和运算。对CPU进行扩展，增加互联总线、存储器和各种各样的I/O接口电路，形成完整的计算机系统，并将整个系统集成到单芯片上，即为SoC。SoC具有集成度高、功耗低、体积小等优点，在嵌入式系统领域中被广泛应用。

&emsp;&emsp;本实验提供的SoC架构如图2-5所示。32位的多周期RISC-V处理器核心`cpu_core`通过内部总线和哈佛结构的Cache连接到AXI总线控制模块`axi_master`。`axi_master`接收并解析`cpu_core`的访问请求，并将请求发送到总线桥模块。总线桥模块根据请求中的地址，将来自`axi_master`的指令或数据访问请求转发给相应的从设备（主存或外设）。

<center><img src="../assets/2-5.png" width = 370></center>
<center>图2-5 SoC架构图</center>

!!! info "SoC执行指令的简要过程 :books:"
    &emsp;&emsp;由图2-5可知，`cpu_top`模块对外是冯·诺依曼结构，即指令和数据均存储在AXI总线桥下的主存模块。
    
    &emsp;&emsp;程序运行时，`cpu_core`以`PC`寄存器的值作为指令的地址，向`ICache`发出取指令请求。若`ICache`中已经缓存有相应的指令，则直接将指令返回给`cpu_core`；否则`ICache`将向`axi_master`模块发出读访问请求。
    
    &emsp;&emsp;`axi_master`模块接收请求后，以AXI总线协议向下一级的AXI总线桥发出访问请求。AXI总线桥接收到请求后，根据请求中的地址，判断需要访问哪个设备，并向相应设备发出读请求。指令被从主存取出后，再依次经过AXI总线桥、`axi_master`和`ICache`，最终传输到`cpu_core`。

    &emsp;&emsp;`cpu_core`接收到指令后，分别对指令进行译码、取操作数、产生控制信号、作数据运算、写回执行结果等操作，从而完成指令的执行。

&emsp;&emsp;在图2-5中，处理器核`cpu_core`在执行乘除法指令时，将调用ALU中的乘法器和除法器来完成乘除法运算。

&emsp;&emsp;在本实验中，除了乘法器、除法器之外的其余模块，均已提供好。
